{
  "model": "deepseek-coder:1.3b",
  "timestamp": "2025-06-22T20:48:21.334742",
  "categories": {
    "simple_lookups": [
      {
        "query": "Who is the CTO?",
        "generated_cypher": "MATCH (p:Person) WHERE p.name = 'Chris Test' RETURN p LIMIT 1;",
        "generation_time": 2.5214340686798096,
        "execution_time": 0.005043506622314453,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 0
      },
      {
        "query": "List all teams in the engineering department",
        "generated_cypher": "MATCH (t:Team) WHERE t.department = 'engineering' RETURN t",
        "generation_time": 0.21857786178588867,
        "execution_time": 0.003191232681274414,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": false,
        "pattern_match": true,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 0
      },
      {
        "query": "Find employees in the Berlin office",
        "generated_cypher": "MATCH (p1:Person) WHERE p1.location = 'Berlin' RETURN DISTINCT p1 ORDER BY p1.name LIMIT 5;",
        "generation_time": 0.300351619720459,
        "execution_time": 0.008928537368774414,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": true,
        "pattern_match": true,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 5
      }
    ],
    "filtered_searches": [
      {
        "query": "Show me senior engineers with Python and React skills",
        "generated_cypher": "MATCH (p1:Person) WHERE p1.name =~ 'Senior Engineer' AND toLower(p1.skills[*].type) CONTAINS['Python', 'React'] RETURN collect(p1);  -- assuming Python and React are skills with ids like \"SkillType-python\" or \"SkillType-react\".",
        "generation_time": 0.5344209671020508,
        "execution_time": 0.002089977264404297,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "Find all critical security policies updated this year",
        "generated_cypher": "MATCH (pol:Policy) WHERE pol.updated_at > DATEADD(YEAR, -1)' AND CASE WHEN TOLOWER(pol.name CONTAINS 'security') THEN TRUE ELSE FALSE END OR \u2026; // continue with the rest of your query pattern if needed ...",
        "generation_time": 0.43805694580078125,
        "execution_time": 0.0019364356994628906,
        "syntax_valid": false,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "Which teams have more than 10 members?",
        "generated_cypher": "MATCH (t:Team)<-(p)-[:MEMBER_OF {is_lead : true}]->(q:Person) WHERE size((q)) > 10 RETURN t, count(q), collect([x for x in relationships(p)] order by type(each(relationships(p)))",
        "generation_time": 0.46138644218444824,
        "execution_time": 0.002065896987915039,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input '(': expected '-' or '[' line: 1, column: 17, offset: 16 errCtx: MATCH (t:Team)<-(p)-[:MEMBER_OF {is_lead : true}]->(q:Person) WHERE size((q))... errCtxOffset: 16",
        "result_count": 0
      }
    ],
    "aggregations": [
      {
        "query": "How many people work in each department?",
        "generated_cypher": "MATCH (p:Person)-[:WORKS_AT]->(o) RETURN o.department AS DepartmentName , count(distinct p) as NumberOfPeopleInDepartment, sum(p.seniority + p.hire_date )  totalSeniorities GROUP BY DepartmentName ORDER BY TotalSeniorities DESC",
        "generation_time": 0.5055708885192871,
        "execution_time": 0.0017580986022949219,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input 't': expected '.', AND, OR, XOR, NOT, '=~', '=', '<>', '+', '-', '*', '/', '%', '^', IN, CONTAINS, STARTS WITH, ENDS WITH, '<=', '>=', '<', '>', IS NULL, IS NOT NULL, '[', '{', a label, AS, ',', ORDER BY, SKIP, LIMIT, ';', call clause or a clause line: 1, column: 157, offset: 156 errCtx: ...nt, sum(p.seniority + p.hire_date )  totalSeniorities GROUP BY DepartmentN... errCtxOffset: 40",
        "result_count": 0
      },
      {
        "query": "What's the average team size across all departments?",
        "generated_cypher": "MATCH (department)<-(member)-(teamMember)->() WHERE NOT member[is_lead] RETURN AVG((SIZE)((manager in NEIGHBORS(*))-[:MEMBER_OF]-'())) AS averageTeamSize; \nThis query finds all teams and their managers, then calculates the count of neighbors (i.e., those people who manage a team), which gives us an estimate for each person's \"team size\" across departments. The final result is that we get back exactly one value: this would be equivalent to average number in terms per department or company unit if there are more than 10 employees with the same count of teams managed by them (as it depends on how many people do a team work).",
        "generation_time": 0.9554145336151123,
        "execution_time": 0.0020093917846679688,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "Show the distribution of seniority levels by location",
        "generated_cypher": "MATCH (p:Person) WHERE TOLOWER(p.name) = 'X' AND p.seniority IS NOT NULL RETURN DISTINCT p.location AS Locations, ARRAY_AGG(DISTINCT p.seniority ORDER BY p.seniority ASC LIMIT 10)[0..9] as Seniorities\nORDER BY COUNT (p) DESC;   # assuming seniority is numeric and higher values represent lower level of authority ie: \"highest\" or the least represented by a team member - with highest being most common, lowest having fewest. Here 'X' should be replaced on user request to get data for specific person",
        "generation_time": 0.8730282783508301,
        "execution_time": 0.0023636817932128906,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      }
    ],
    "multi_hop_relationships": [
      {
        "query": "Find all people who report to someone in the data team",
        "generated_cypher": "MATCH (p1:Person)-[:REPORTS_TO]->(t2) WHERE t2.name = 'data team' RETURN p1 LIMIT 50;",
        "generation_time": 0.31786322593688965,
        "execution_time": 0.007287263870239258,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 0
      },
      {
        "query": "Which policies affect teams working on customer projects?",
        "generated_cypher": "MATCH (pol:Policy) WHERE pol.category CONTAINS 'customer' OR LOWER(pol.name) CONTAINS 'projects' RETURN distinct pol ORDER BY size((p:Person)-[:RESPONSIBLE_FOR]->(pol)) DESC LIMIT 10",
        "generation_time": 0.45807909965515137,
        "execution_time": 0.002344846725463867,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "Unknown function 'LOWER'",
        "result_count": 0
      },
      {
        "query": "Show me engineers who work with clients in the financial sector",
        "generated_cypher": "MATCH (p:Person)-[:HAS_SKILL]->(s:Skill {name:'Financial'})-[]-(c:Client) RETURN p, c LIMIT 10;",
        "generation_time": 0.33496689796447754,
        "execution_time": 0.0027010440826416016,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 0
      }
    ],
    "path_finding": [
      {
        "query": "What's the reporting chain from junior developers to the CEO?",
        "generated_cypher": "Based on your schema and relationship patterns you can generate a Neo4j based cypher queries for \"Who manages/leads X team\", \"Find X policies\",\"who's responsible for x\" ,  'People in X department or location', etc. The CYPHER query would be something like:\n1. For who manages / leads X Team, use :MEMBER_OF where is lead = true and then match the person node with MEMBER OF relationship to team nodes using (t), name of 'X' as parameter in t property will return a list containing all junior developers managing/leading teams named \"X\".\n2. For finding x policies:  use WHERE clause on pol properties where category or name contains substring from user input and then match policy node with MATCH relationship to person nodes using (p), 'x' as parameter in the condition, will return a list of Policies related considering case-insensitive matching by comparing them.\n3. For who\u2019s responsible for x:  use WHERE clause on pol properties where category or name contains substring from user input and then match policy node with RESPONSIBLE_FOR relationship to entity nodes using (pol), 'x' as parameter in the condition, will return a list of Policies that are Responsible.\n4. For people in X department / location:  use WHERE clause on person properties where departments or locations contain substring from user input and then match Person node with MEMBER OF relationship to Team nodes using (p), 'X' as parameter, will return a list of persons working under the team/department named \"X\".\n    You can adapt this pattern for other queries in similar manner.  Also note that you might need more complex query if your database schema is not normalized and has multiple levels or paths to follow from one node towards another without directly connecting them with relationship nodes as Cypher does, where the relationships are indirectly represented using path traversal (like 'parent-child' relations) for a better performance.",
        "generation_time": 2.425269603729248,
        "execution_time": 0.002626180648803711,
        "syntax_valid": false,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input 'B': expected ';', ':', a statement option, a query hint, call clause, a clause or a schema command line: 1, column: 1, offset: 0 errCtx: Based on your schema and relationship patterns you can generate a Neo4j based... errCtxOffset: 0",
        "result_count": 0
      },
      {
        "query": "Find all connections between the security team and compliance policies",
        "generated_cypher": "MATCH (t:Team {name:'Security'})<-[:MEMBER_OF]-(p1)-[*]->(pol2) WHERE p1.role = 'security manager' AND ID(pol2) IN [policy in relationships(t) where toLower(policy.category)=toLower('Compliance')] RETURN collect(DISTINCT pol2), count(*)",
        "generation_time": 0.5661485195159912,
        "execution_time": 0.0029785633087158203,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": true,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 1
      },
      {
        "query": "Show how the product team collaborates with engineering",
        "generated_cypher": "MATCH (p1:Person)-[:MEMBER_OF {is_lead : true}]->(t)<-[:MEMBER_OF]-(p2), p3, l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR t.department='Y' RETURN DISTINCT p1 as teamLeader, count(distinct p2) AS numManagedByEngineeringTeam\nEND MATCH (p:Person)-[:HAS_SKILL]->(s), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR s.category='Y' RETURN DISTINCT p as developers, count(distinct c) AS numDevelopedSkills\nEND MATCH (p:Person)-[:WORKS_AT]->(o), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR o.city='Y' RETURN DISTINCT p as teamMembers, count(distinct s) AS numRegions\nEND MATCH (p:Person)-[:ON_CALL]->(s), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR dateformat(s.start_datetime,'YY-MM')=dateformat('Y',now()) RETURN DISTINCT p as onCallPersons, count(distinct s) AS numOnCll\nEND MATCH (p:Person)-[:HAS_VISA]->(v), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR v.type='Y' RETURN DISTINCT p as visaApplicants, count(distinct s) AS numVisas\nEND MATCH (p:Person)-[:REPORTS_TO]->(r), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR r.email='Y@example..com' RETURN DISTINCT p as reportsTo, count(distinct t) AS numReports\nEND MATCH (p:Person)-[:ALLOCATED_TO]->(pr), l:(Group|Policy)] WHERE toLower(l.name) = 'X' OR pr.type='Y', status NOT IN ['Closed'] RETURN DISTINCT p as allocatedProjects, count(distinct pr) AS numAllocated\nEND MATCH (p:Person)-[:RESPONSIBLE_FOR]->((l)), l:(Team|Policy)] WHERE toLower(t.name) = 'X' OR t.focus='Y', p NOT IN ['Product Team'] RETURN DISTINCT p as responsiblePeople, count(distinct rp) AS numResponses\nEND MATCH (pr:Person)-[:WORKS_AT]->((l)), l:(Team|Policy)] WHERE toLower(t.name) = 'X' OR t.budget=Y RETURN DISTINCT pr as teams, count(distinct wp), sum(wf::numAllocated)/sum(wp:numWorstFactor)*10 AS averageAllocation\nEND MATCH (prj : Project)<-[:ALLOCATED_TO]-(rp)->(pp), l:(Team|Policy)] WHERE toLower(t.name) = 'X' OR prj.type=Y RETURN DISTINCT pp as projectPersons, count(distinct pnr:numResponses + numAllocated - 10 AS total\nEND MATCH (pr : Client), l:(Team|Policy)] WHERE toLower(t.name) = 'X' OR prj=Y RETURN DISTINCT t as clients, count((distinct wp)), sum ((total)/numClients*10 )AS averageValue\nEND MATCH (pr:Person)-[:ON_CALL]->-(s), l:(Compliance|Policy)] WHERE toLower(l.name) = 'X' OR dateformat(dateadd('day', 3, s.startdatetime ), '%Y-%m')=toDateTime({now()+24*60}) RETURN DISTINCT p as onCallPersons\nEND MATCH (c:Compliance)-[:ON_CALL]->-(s), l:(Office|Policy)] WHERE toLower(l.name) = 'X' OR dateformat((dateadd('day', 3, s.startdatetime )-24*60 ), '%Y')=toDateTime({now()+18}) RETURN DISTINCT c as complianceCenters\nEND MATCH (c:Compliance)-[:ON",
        "generation_time": 6.023797273635864,
        "execution_time": 0.0023810863494873047,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input ',': expected '=' line: 1, column: 76, offset: 75 errCtx: ... : true}]->(t)<-[:MEMBER_OF]-(p2), p3, l:(Group|Policy)] WHERE toLower(l.n... errCtxOffset: 40",
        "result_count": 0
      }
    ],
    "complex_patterns": [
      {
        "query": "Find circular reporting structures (people who indirectly report to themselves)",
        "generated_cypher": "MATCH (p1), (m)<-(r)->(p2) WHERE ID(p1) = idOfPerson AND NOT ID(p2) IN [ID(n) for n in relationships(r)]  RETURN p1, m, r , collect([id(e) foreach e in relationshipPath(r,-)] as path )",
        "generation_time": 0.5094702243804932,
        "execution_time": 0.0017955303192138672,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input '(': expected '-' or '[' line: 1, column: 18, offset: 17 errCtx: MATCH (p1), (m)<-(r)->(p2) WHERE ID(p1) = idOfPerson AND NOT ID(p2) IN [ID(n)... errCtxOffset: 17",
        "result_count": 0
      },
      {
        "query": "Which teams have members with skills that no other team has?",
        "generated_cypher": "MATCH (p1) WHERE ID(p1) = 'X' WITH p1 MATCH (t)-[:MEMBER_OF {role}]->(:Team), count((s)-[*]->()) AS skillCount, collect({id:(ID($0))}) as teamIds RETURN reduce(teamIds[] as set, \n   ((a, b) ->  a.concat([b]))) in [x IN nodes(p1)]-[:REPORTS_TO]->() WHERE NOT EXISTS (((t)-[r*])-(s)) AND skillCount = 0 AS result LIMIT 5;",
        "generation_time": 0.9755637645721436,
        "execution_time": 0.001936197280883789,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input '}': expected ':' line: 1, column: 66, offset: 65 errCtx: ...' WITH p1 MATCH (t)-[:MEMBER_OF {role}]->(:Team), count((s)-[*]->()) AS sk... errCtxOffset: 40",
        "result_count": 0
      },
      {
        "query": "Identify skill gaps: skills needed by projects but not possessed by allocated team members",
        "generated_cypher": "MATCH (s:Skill) WHERE s.category = 'Project' OR NOT EXISTS ((p1)-[:HAS_SKILL]->(s)) RETURN DISTINCT p2, collect((x:Person {name: none})-[]->(:Team), 50, false)[0] as members\nUNWIND range(3) AS x LIMIT 4 OFFSET (collect ((p1)-[:HAS_SKILL]->())[78]) * floor((size()/2)) + collect ((x:Person {name : none})-[]-(s),5,false)[0] as teamMembers\nMATCH(t:(Team) WITH t ORDER BY size([ (m)-[:ALLOCATED_TO ]->(:Project )  WHERE not member(m at before node(1)) IN [276..398]] LIMIT -x OFFSET x RETURN collect((p:Person {name : none})[0]-(t) MATCH ((r:-[])-[:HAS_SKILL]-> (s)),5,false)[4]) as teamWithSkills\nUNWIND [teamMembers + member(1)] AS tm WITH reduce(member in nodes(tm) where not node(member).name = 'Person' return collect((node(0)(x))-[a:ALLOCATED_TO]->(:Project)-[:HAS_SKILL]-(s),5,false)[2]) as teamWithSkills\nMATCH (p:(Policy {severity : 1})) WITH p ORDER BY size([r:-[]<-[(t):RESPONSIBLE_FOR ] WHERE NOT EXISTS ((m)-[:ALLOCATED_TO]-(s)) IN [73..9524]) LIMIT -x OFFSET x RETURN collect((p:Person {name : none})[0]->(:Team) MATCH (r:-[]-<[(t):RESPONSIBLE_FOR ] WHERE NOT EXISTS ((m)-[:ALLOCATED",
        "generation_time": 2.613909959793091,
        "execution_time": 0.0020558834075927734,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input 'I': expected LOAD CSV line: 2, column: 23, offset: 196 errCtx: UNWIND range(3) AS x LIMIT 4 OFFSET (collect ((p1)-[:HAS_SKILL]->())[78]) * f... errCtxOffset: 22",
        "result_count": 0
      }
    ],
    "ambiguous_requests": [
      {
        "query": "Show me the important people",
        "generated_cypher": "MATCH (p:Person) WHERE p.name =~ '.*(?:[mM][aAnN][gG])' RETURN DISTINCT p LIMIT 10; -- Managers with highest seniority level at any point in time will be returned first, followed by the top managers who are currently managing more teams",
        "generation_time": 0.4952273368835449,
        "execution_time": 0.0018429756164550781,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": true,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "Find problematic areas in the organization",
        "generated_cypher": "MATCH (p1:Person)<-(r1:RESPONSIBLE_FOR)-(pol:Policy), (t2:Team {name:'X'}) WHERE p1 = t2 RETURN pol, r1 LIMIT 50; // Add the actual team name in ' X ', e.g., Find problematic areas responsible for Team ABC",
        "generation_time": 0.5243210792541504,
        "execution_time": 0.0016412734985351562,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "Who should I talk to about AI stuff?",
        "generated_cypher": "MATCH (p1)<-(r)-(:Person {name:\"AI Stuff\", role:'Manager'})->(t2) WHERE p1 = t2 RETURN count(*) AS cnt ORDER BY cnt DESC LIMIT 5;",
        "generation_time": 0.4076273441314697,
        "execution_time": 0.001712799072265625,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": true,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input '(': expected '-' or '[' line: 1, column: 13, offset: 12 errCtx: MATCH (p1)<-(r)-(:Person {name:\"AI Stuff\", role:'Manager'})->(t2) WHERE p1 = ... errCtxOffset: 12",
        "result_count": 0
      }
    ],
    "organizational_insights": [
      {
        "query": "What's the bus factor for critical projects? (how many people would need to leave to endanger the project)",
        "generated_cypher": "MATCH (p:Person)-[:HAS_SKILL]->(skill) WHERE skill.name = 'busFactorForCriticalProjects' RETURN COUNT(DISTINCT p), SUM((40 - CAST([startedAt] AS datetime)) / 60 DIV NULLIF(CAST([endDate] AS date)-[created_at].date, 1) as totalMinutesInBusFactor WHERE project.type = 'critical'",
        "generation_time": 0.6748793125152588,
        "execution_time": 0.001848459243774414,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input 'S': expected AND line: 1, column: 144, offset: 143 errCtx: ...INCT p), SUM((40 - CAST([startedAt] AS datetime)) / 60 DIV NULLIF(CAST([en... errCtxOffset: 40",
        "result_count": 0
      },
      {
        "query": "Find potential compliance violations: teams without required policy training",
        "generated_cypher": "MATCH(p1:Person) WHERE toLower(p1.department) = 'X' OR p1.name CONTAINS '/^X/i' RETURN count(DISTINCT p1), collect(distinct p1)[0..2]  // Display first three members",
        "generation_time": 1.2523515224456787,
        "execution_time": 0.0025665760040283203,
        "syntax_valid": true,
        "execution_success": true,
        "has_results": true,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": null,
        "result_count": 1
      },
      {
        "query": "Identify knowledge silos: skills possessed by only one person in a team",
        "generated_cypher": "MATCH (p1:Person)<-[:MEMBER_OF {role:'X', is_lead: true}]-(t:Team), p2:(Skill) WHERE NOT (([s:SKILL] ->(+)) FROM 0..3 OUTBOUND WHERE t.id = id ) MATCH (p1)-[[r*]]-(:Person)--() AND r.[name CONTAINS 'X'] RETURN COUNT([x IN [((m)[2])...[s][:type] SUBSTRING(9, 0..3)",
        "generation_time": 0.7613711357116699,
        "execution_time": 0.001714468002319336,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "errMsg: Invalid input ':': expected '=' line: 1, column: 71, offset: 70 errCtx: ...ole:'X', is_lead: true}]-(t:Team), p2:(Skill) WHERE NOT (([s:SKILL] ->(+))... errCtxOffset: 40",
        "result_count": 0
      }
    ],
    "edge_cases": [
      {
        "query": "Find people named John or Jon (handle name variations)",
        "generated_cypher": "MATCH (p1:Person {name:'John'}) UNION MATCH (p2:Person {name:'Jon'}) RETURN p1 , p2; -- Union of both match patterns and return the union entities. Without LIMIT, there can be multiple results for each entity in case they have same names ('john', 'jon')",
        "generation_time": 0.5132379531860352,
        "execution_time": 0.0014743804931640625,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": true,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "What happens if everyone in the data team leaves?",
        "generated_cypher": "MATCH (p:Person)<-(r1:MEMBER_OF)-(t:Team {name:'data'})-[:REPORTS_TO]->(entity2:Office), ((person: Person, tz : Timezone)) WHERE p.id \u2260 person.manager_id AND TIMEZONE('+03:00',tz) = 'UTC'-((p)-[r1*]-(t)); DELETE r1;",
        "generation_time": 0.6611428260803223,
        "execution_time": 0.0013587474822998047,
        "syntax_valid": false,
        "execution_success": false,
        "has_results": false,
        "pattern_match": false,
        "complexity_appropriate": false,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      },
      {
        "query": "\u03c0\u0178'\u20af Find team leads \u03c0\u0178'\u20af",
        "generated_cypher": "MATCH (p:Person)<-(m:MemberOf)->(t:Team {name : 'X'}) WHERE m.is_lead = true RETURN p, t LIMIT 10; // Assuming X is the team name you are looking for and replace it with your actual parameter",
        "generation_time": 0.4505589008331299,
        "execution_time": 0.001443624496459961,
        "syntax_valid": true,
        "execution_success": false,
        "has_results": false,
        "pattern_match": true,
        "complexity_appropriate": true,
        "handles_ambiguity": true,
        "error": "Error: query with more than one statement is not supported.",
        "result_count": 0
      }
    ]
  },
  "overall_metrics": {
    "total_queries": 27,
    "syntax_valid": 24,
    "execution_success": 7,
    "has_results": 3,
    "pattern_matches": 6,
    "avg_generation_time": 0.9916306513327139,
    "avg_execution_time": 0.002633209581728335,
    "category_scores": {
      "simple_lookups": 0.6666666666666666,
      "filtered_searches": 0.0,
      "aggregations": 0.0,
      "multi_hop_relationships": 0.0,
      "path_finding": 0.0,
      "complex_patterns": 0.0,
      "ambiguous_requests": 0.0,
      "organizational_insights": 0.0,
      "edge_cases": 0.0
    }
  },
  "overall_score": 37.03703703703704
}